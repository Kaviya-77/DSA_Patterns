Count the Number of Complete Components
You are given an integer n. There is an undirected graph with n vertices, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting vertices ai and bi.
Return the number of complete connected components of the graph.A connected component is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.
A connected component is said to be complete if there exists an edge between every pair of its vertices.

Example 1:

Input: n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]
Output: 3
Explanation: From the picture above, one can see that all of the components of this graph are complete.


edges=nodes∗(nodes−1)/2​

Edges are counted when iterating neighbors
➝ because every adjacency = 1 edge instance

Nodes are counted when visiting new nodes
➝ because each distinct node should be counted once



class Solution {
    public int countCompleteComponents(int n, int[][] edges) {
        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();

        for(int i=0;i<n;i++){
            adj.add(new ArrayList<>());
        }

        for(int i=0;i<edges.length;i++){
            int u=edges[i][0];
            int v=edges[i][1];
            adj.get(u).add(v);
            adj.get(v).add(u);
        }

        //if edges=nodes*(nodes-1)/2 which is true then there is complete components is there for every connected components
        //need to calculate edge and node using bfs or dfs so using non primary variable for parsing

       
        boolean visited[]=new boolean[n];
        int count=0;
        for(int i=0;i<n;i++){
            if(!visited[i]){
                 int[] edgeAndNode=new int[2]; //0-->no of edges, 1-->no of node
                //dfs(visited,i,adj,edgeAndNode);
                bfs(visited,adj,edgeAndNode,i);
                edgeAndNode[0]/=2; //edge got divided by 2 because counted 2 times
                edgeAndNode[1]++;  // node increased by 1 because only neighbours counted in the dfs so for the current node it get increased by 1
                //edge=node*(node-1)/2
                if(edgeAndNode[0]==(edgeAndNode[1]*(edgeAndNode[1]-1)/2)){
                    count++;
                }

            }
        }
        return count;

    }

    public static void dfs(boolean visited[],int node,ArrayList<ArrayList<Integer>> adj,int temp[]){
        visited[node]=true;
        for(int i:adj.get(node)){
            //the node has neighbours so edge will be there,so increase the edge value
            temp[0]++; // 2 times got incremented because of undirected graph
            if(!visited[i]){
                //one unique node is connected with the current node so increase the node value
                temp[1]++;
                visited[i]=true;
                dfs(visited,i,adj,temp);
            }
        }
    }
    public static void bfs(boolean visited[],ArrayList<ArrayList<Integer>> adj,int temp[],int node){
        Queue<Integer> q=new LinkedList<>();
        q.add(node);
        visited[node]=true;
        while(!q.isEmpty()){
            int val=q.poll();
            for(int n:adj.get(val)){
                temp[0]++;
                if(!visited[n]){
                    temp[1]++;
                    q.add(n);
                    visited[n]=true;
                }
            }
        }
    }
}
