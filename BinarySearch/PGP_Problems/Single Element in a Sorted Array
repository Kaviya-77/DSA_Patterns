You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
Return the single element that appears only once.
Your solution must run in O(log n) time and O(1) space.
Example 1:
Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2

/////////Intution///////////////
1ï¸âƒ£ Pairs come in even-odd order before the single element:
(even, odd), (even, odd) âœ…
2ï¸âƒ£ After the single element, pairs shift:
(odd, even), (odd, even) âŒ (pattern broken)
3ï¸âƒ£ Use mid index parity to detect where the pattern breaks:
mid even â†’ should match mid+1
mid odd â†’ should match mid-1
4ï¸âƒ£ If mismatch â†’ single is on the left including mid,
otherwise single is on the right â†’ move boundaries accordingly.
ğŸ“Œ Finally, when start == end, that index is the single element âœ…
//////////////////////////////////

class Solution {
    public int singleNonDuplicate(int[] nums) {
        int start=0;
        int end=nums.length-1;
        while(start<end){
            int mid=start+(end-start)/2;
            if(mid%2==0){ ///mid is even
              if(nums[mid]==nums[mid+1]){ // pattern not breaks so unique lies on right side
                start=mid+1;
              }
              else{ 
                end=mid; ///if pattern breaks only unique present in the left side
              }
            }
            else { //mid is odd
               if(nums[mid]==nums[mid-1]){ //pattern not breaks so unique lies on rigth side only
                  start=mid+1;
               }
               else{
                  end=mid;
               }
            }
       }
        return nums[start];
    }
}
