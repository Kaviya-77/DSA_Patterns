Given an array arr[] of size n, containing elements from the range 1 to n, and each element appears at most twice, return an array of all the integers that appears twice.
Note: You can return the elements in any order but the driver code will print them in sorted order.
Examples:
Input: arr[] = [2, 3, 1, 2, 3]
Output: [2, 3] 
Explanation: 2 and 3 occur more than once in the given array.

//////////Intution////////////
Using binary search will not be because the array is not sorted , so sorting take O(nlogn), instead of this we can use boolean marking and index marking 
technique with O(n) time complexity
/////////////////////////////

class Solution {
    public ArrayList<Integer> findDuplicates(int[] nums) {
       // boolean flag[]=new boolean[arr.length+1];
        ArrayList<Integer> ans=new ArrayList<>();
        // for(int i=0;i<arr.length;i++){
        //     if(flag[arr[i]]){
        //         ans.add(arr[i]);
        //     }
        //     flag[arr[i]]=true;
        // }
        // return ans;
        
        //without extra array
        for(int i=0;i<nums.length;i++){
            int idx = Math.abs(nums[i]) - 1; // map value to index
            
            if (nums[idx] < 0) {
                ans.add(Math.abs(nums[i])); // already visited â†’ duplicate
            } else {
                nums[idx] = -nums[idx]; // mark as visited
            }
        }
        return ans;
    }
}
