/*****A peak element is an element that is strictly greater than its neighbors.
Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.
You must write an algorithm that runs in O(log n) time.
Example 1:
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2. *****/

///////////Intution/////////////////
Look at mid and mid+1:
If nums[mid] < nums[mid+1] → we are on an ascending slope at mid.
⇒ There must be a peak somewhere to the right of mid (could be mid+1 or later).
Safe move: start = mid + 1.
If nums[mid] > nums[mid+1] (or >=) → we are on a descending slope at mid.
⇒ There must be a peak at mid or to the left.
Safe move: end = mid (keep mid in the search).
These two rules always keep at least one peak inside [start,end].

edge cases
Single element → it’s a peak.
Strictly increasing array → last element is the peak.
Strictly decreasing array → first element is the peak.
Multiple peaks → algorithm will converge to one valid peak.
Repeated values are fine (compare with >= if you want to treat flat slopes deterministically).
////////////////////////////////////////


class Solution {
    public int findPeakElement(int[] nums) {
        //any peak element we can return not necessary to return highest one
        if(nums.length==1) return 0;
        int start=0;
        int end=nums.length-1;
        while(start<end){
            int mid=start+(end-start)/2;
            if(nums[mid]<nums[mid+1]){
                //any peak lies in right side
                start=mid+1;
            }
            else{
                end=mid;
            }
        }
        return start;
    }
}
